<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Générateur de Chiffres</title>
  <style>
    @font-face {
      font-family: 'Bangers';
      src: url('C:/Users/rapha/Documents/pixijs/Game2/pixi-project-template-main/src/assets/fonts/Bangers_v2/Bangers-Regular.woff2') format('woff2');
      font-style: normal;
      font-weight: 400;
      font-display: swap;
    }
    
    body {
      font-family: 'Arial', sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    
    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }
    
    .controls {
      background-color: #fff;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 10px;
    }
    
    .control-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    
    input, select, button {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    
    input[type="color"] {
      height: 40px;
      padding: 2px;
    }
    
    input[type="number"] {
      width: 100%;
      text-align: center;
    }
    
    /* Style pour les contrôles du gradient */
    .gradient-control {
      display: grid;
      grid-template-columns: 80px 1fr 120px;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .gradient-color-label {
      width: 80px;
      text-align: right;
      font-size: 14px;
    }
    
    .gradient-color {
      width: 100%;
      height: 40px;
      padding: 2px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    
    .gradient-position {
      width: 100%;
      text-align: center;
    }
    
    .gradient-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    
    .gradient-header span {
      font-size: 12px;
      color: #666;
    }
    
    .buttons {
      grid-column: 1 / -1;
      display: flex;
      gap: 10px;
    }
    
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    button#downloadAll {
      background-color: #2196F3;
    }
    
    button#downloadAll:hover {
      background-color: #0b7dda;
    }
    
    .characters-input {
      grid-column: 1 / -1;
    }
    
    .preview-container {
      background-color: #fff;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .preview {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      padding: 20px;
      border-radius: 4px;
      background-color: #f9f9f9;
      min-height: 100px;
      overflow-x: auto;
    }
    
    /* Amélioration de l'affichage des prévisualisations */
    .preview-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: white;
      border-radius: 6px;
      padding: 15px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      position: relative;
    }
    
    .preview-image-container {
      background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAABnSURBVHja7M6xDQAgDAPA0vef3BmcA0RpKMwQSHT5Jvh9Mvb9JqSqGnvODO0b2vrGelRrDbd3/MiAGaeBBdMxYjL0dGYyWkx3HhtugXYL2DA7WNppMMIUQlsvs2Caf6QZE1nQPwAAAP//AwAYhgckvOAFCQAAAABJRU5ErkJggg==');
      border: 1px dashed #aaa;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
      position: relative;
    }
    
    .preview-image-container img {
      display: block;
    }
    
    .image-dimensions {
      position: absolute;
      bottom: -8px;
      right: -8px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 10px;
      padding: 2px 5px;
      border-radius: 3px;
    }
    
    .preview-item .char-label {
      margin-top: 10px;
      font-size: 14px;
      color: #333;
      background-color: #f0f0f0;
      padding: 3px 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
      font-weight: bold;
    }
    
    .font-loader {
      font-family: 'Bangers';
      visibility: hidden;
      position: absolute;
      pointer-events: none;
    }
    
    #previewer {
      margin-top: 20px;
      font-family: 'Bangers';
      font-size: 40px;
      padding: 15px;
      background-color: #333;
      color: white;
      border-radius: 4px;
      text-align: center;
      grid-column: 1 / -1;
    }
    
    #background-selector {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 15px;
    }
    
    #background-selector div {
      width: 40px;
      height: 40px;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s;
      position: relative;
    }
    
    #background-selector div:hover {
      transform: scale(1.1);
    }
    
    #background-selector div.active {
      outline: 3px solid #2196F3;
    }
    
    #background-selector div:nth-child(1) { background-color: #333; }
    #background-selector div:nth-child(2) { background-color: #2196F3; }
    #background-selector div:nth-child(3) { background-color: #4CAF50; }
    #background-selector div:nth-child(4) { background-color: #f44336; }
    #background-selector div:nth-child(5) { 
      background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAABnSURBVHja7M6xDQAgDAPA0vef3BmcA0RpKMwQSHT5Jvh9Mvb9JqSqGnvODO0b2vrGelRrDbd3/MiAGaeBBdMxYjL0dGYyWkx3HhtugXYL2DA7WNppMMIUQlsvs2Caf6QZE1nQPwAAAP//AwAYhgckvOAFCQAAAABJRU5ErkJggg=='); 
    }
    
    /* Message pour les problèmes de chargement de police */
    #font-error {
      display: none;
      background-color: #ffdddd;
      border-left: 6px solid #f44336;
      padding: 15px;
      margin-bottom: 20px;
    }
    
    /* Nouveaux styles pour l'option de dimensions uniformes */
    .uniform-size-option {
      margin-top: 15px;
      grid-column: 1 / -1;
      padding: 15px;
      background-color: #f0f8ff;
      border-radius: 6px;
      border: 1px solid #cce5ff;
    }
    
    .uniform-size-header {
      font-weight: bold;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .uniform-size-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 10px;
    }
    
    /* Style pour les paddings individuels */
    .padding-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    
    .padding-group {
      display: flex;
      flex-direction: column;
    }
    
    .padding-label {
      font-size: 12px;
      margin-bottom: 3px;
      color: #666;
    }
    
    .checkbox-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    
    .checkbox-control input[type="checkbox"] {
      width: auto;
      margin: 0;
    }
    
    .uniform-size-chars {
      width: 100%;
    }
    
    /* Contrôles de prévisualisation */
    .preview-controls {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .zoom-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .zoom-label {
      font-weight: bold;
      white-space: nowrap;
    }
    
    .zoom-buttons {
      display: flex;
      gap: 5px;
    }
    
    .zoom-button {
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 3px 8px;
      cursor: pointer;
      font-weight: bold;
    }
    
    .zoom-button:hover {
      background-color: #e0e0e0;
    }
    
    .zoom-value {
      width: 60px;
      text-align: center;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 3px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="font-loader">Bangers</div>
  
  <h1>Générateur de Chiffres pour Machine à Sous</h1>
  
  <div id="font-error">
    <p><strong>Attention :</strong> Le chargement de la police locale a échoué. Nous utiliserons une police de remplacement.</p>
    <p>Pour résoudre ce problème, vous pouvez :</p>
    <ul>
      <li>Vérifier que le chemin vers votre police est correct</li>
      <li>Placer ce fichier HTML dans le même dossier que votre police et modifier le chemin</li>
      <li>Utiliser un serveur local pour éviter les restrictions de sécurité du navigateur</li>
    </ul>
  </div>
  
  <div class="controls">
    <div class="control-group">
      <label for="fontSize">Taille de police (px)</label>
      <input type="number" id="fontSize" min="20" max="400" value="120" step="1">
    </div>

    <div class="control-group">
      <label for="strokeWidth">Épaisseur du contour (px)</label>
      <input type="number" id="strokeWidth" min="1" max="30" value="8" step="1">
    </div>

    <div class="control-group">
      <label for="strokeColor">Couleur du contour</label>
      <input type="color" id="strokeColor" value="#550055">
    </div>

    <!-- Section pour le gradient -->
    <div class="control-group" style="grid-column: 1 / -1;">
      <label>Configuration du gradient</label>
      
      <div class="gradient-header">
        <span>Direction horizontale du gradient (0-100%)</span>
      </div>
      <input type="range" id="gradientDirectionX" min="0" max="100" value="0" step="1">
      <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
        <span style="font-size: 12px;">Vertical (0%)</span>
        <span style="font-size: 12px;">Diagonal (50%)</span>
        <span style="font-size: 12px;">Horizontal (100%)</span>
      </div>

      <!-- Contrôles pour les couleurs du gradient -->
      <div class="gradient-control">
        <span class="gradient-color-label">Couleur 1:</span>
        <input type="color" id="gradientColor1" class="gradient-color" value="#ffd700">
        <input type="number" id="gradientPos1" class="gradient-position" min="0" max="100" value="0" step="1">
      </div>
      
      <div class="gradient-control">
        <span class="gradient-color-label">Couleur 2:</span>
        <input type="color" id="gradientColor2" class="gradient-color" value="#ffcc00">
        <input type="number" id="gradientPos2" class="gradient-position" min="0" max="100" value="30" step="1">
      </div>
      
      <div class="gradient-control">
        <span class="gradient-color-label">Couleur 3:</span>
        <input type="color" id="gradientColor3" class="gradient-color" value="#ff9900">
        <input type="number" id="gradientPos3" class="gradient-position" min="0" max="100" value="60" step="1">
      </div>
      
      <div class="gradient-control">
        <span class="gradient-color-label">Couleur 4:</span>
        <input type="color" id="gradientColor4" class="gradient-color" value="#ff6347">
        <input type="number" id="gradientPos4" class="gradient-position" min="0" max="100" value="100" step="1">
      </div>
    </div>

    <div class="control-group">
      <label for="shadowColor">Couleur de l'ombre</label>
      <input type="color" id="shadowColor" value="#000000">
    </div>

    <div class="control-group">
      <label for="shadowBlur">Flou de l'ombre (px)</label>
      <input type="number" id="shadowBlur" min="0" max="50" value="5" step="1">
    </div>

    <div class="control-group">
      <label for="shadowOffsetX">Décalage X de l'ombre (px)</label>
      <input type="number" id="shadowOffsetX" min="-50" max="50" value="4" step="1">
    </div>

    <div class="control-group">
      <label for="shadowOffsetY">Décalage Y de l'ombre (px)</label>
      <input type="number" id="shadowOffsetY" min="-50" max="50" value="4" step="1">
    </div>

    <!-- Remplacer les contrôles de padding uniques par des contrôles individuels -->
    <div class="control-group">
      <label>Padding (px)</label>
      <div class="padding-controls">
        <div class="padding-group">
          <span class="padding-label">Haut</span>
          <input type="number" id="paddingTop" min="0" max="100" value="10" step="1">
        </div>
        <div class="padding-group">
          <span class="padding-label">Droite</span>
          <input type="number" id="paddingRight" min="0" max="100" value="10" step="1">
        </div>
        <div class="padding-group">
          <span class="padding-label">Bas</span>
          <input type="number" id="paddingBottom" min="0" max="100" value="10" step="1">
        </div>
        <div class="padding-group">
          <span class="padding-label">Gauche</span>
          <input type="number" id="paddingLeft" min="0" max="100" value="10" step="1">
        </div>
      </div>
    </div>

    <div class="control-group characters-input">
      <label for="characters">Caractères à générer</label>
      <input type="text" id="characters" value="0123456789.,x€$£%" placeholder="Caractères à générer">
    </div>

    <!-- Option pour les dimensions uniformes -->
    <div class="uniform-size-option">
      <div class="uniform-size-header">
        <div class="checkbox-control">
          <input type="checkbox" id="useUniformSize">
          <label for="useUniformSize">Utiliser des dimensions uniformes pour certains caractères</label>
        </div>
      </div>
      <div class="uniform-size-controls">
        <div>
          <label for="uniformSizeChars">Caractères concernés</label>
          <input type="text" id="uniformSizeChars" class="uniform-size-chars" value="0123456789" placeholder="Par exemple: 0123456789">
        </div>
      </div>
    </div>

    <div id="previewer">Aperçu: 12,345.67€</div>

    <div class="control-group">
      <label>Couleur d'arrière-plan pour l'aperçu</label>
      <div id="background-selector">
        <div class="active" data-color="#333"></div>
        <div data-color="#2196F3"></div>
        <div data-color="#4CAF50"></div>
        <div data-color="#f44336"></div>
        <div data-color="transparent"></div>
      </div>
    </div>

    <div class="buttons">
      <button id="generate">Générer les images</button>
      <button id="downloadAll">Télécharger toutes les images</button>
    </div>
  </div>
  
  <div class="preview-container">
    <div class="preview-header">
      <h2>Aperçu des images générées</h2>
      <div class="preview-controls">
        <div class="zoom-control">
          <span class="zoom-label">Zoom:</span>
          <div class="zoom-buttons">
            <button class="zoom-button" id="zoom-out">-</button>
            <input type="text" class="zoom-value" id="zoom-value" value="100%" readonly>
            <button class="zoom-button" id="zoom-in">+</button>
          </div>
        </div>
        <div class="checkbox-control">
          <input type="checkbox" id="showBorders" checked>
          <label for="showBorders">Afficher les bordures</label>
        </div>
        <div class="checkbox-control">
          <input type="checkbox" id="showTransparent" checked>
          <label for="showTransparent">Fond transparent</label>
        </div>
      </div>
    </div>
    <div id="preview" class="preview"></div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Chemin local vers la police
      const fontPath = 'C:/Users/rapha/Documents/pixijs/Game2/pixi-project-template-main/src/assets/fonts/Bangers_v2/Bangers-Regular.woff2';
      let fontLoaded = false;
      let currentZoom = 100;
      
      // Fonction pour charger la police
      async function loadLocalFont() {
        try {
          // Tentative de chargement direct de la police
          const fontCheck = new Promise((resolve) => {
            setTimeout(() => {
              // Vérifie si la police est disponible
              if (document.fonts.check('12px Bangers')) {
                console.log('La police Bangers a été chargée avec succès');
                fontLoaded = true;
                resolve(true);
              } else {
                console.warn('La police locale n\'a pas pu être chargée');
                resolve(false);
              }
            }, 500); // Délai court pour laisser la police se charger
          });
          
          const result = await fontCheck;
          if (!result) {
            // Si la police locale échoue, on utilise une police de secours en ligne
            fallbackToWebFont();
          } else {
            initApp();
          }
        } catch (error) {
          console.error('Erreur lors du chargement de la police :', error);
          fallbackToWebFont();
        }
      }
      
      // Fonction de repli sur une police web
      function fallbackToWebFont() {
        document.getElementById('font-error').style.display = 'block';
        console.log('Utilisation de la police web de secours');
        
        const fontLink = document.createElement('link');
        fontLink.href = 'https://fonts.googleapis.com/css2?family=Bangers&display=swap';
        fontLink.rel = 'stylesheet';
        document.head.appendChild(fontLink);
        
        fontLink.onload = () => {
          console.log('Police de secours Bangers chargée');
          setTimeout(initApp, 500);
        };
      }
      
      // Démarrer le chargement de la police
      loadLocalFont();
      
      function initApp() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const previewEl = document.getElementById('preview');
        const previewerEl = document.getElementById('previewer');
        let images = {};
        
        // Gestion des couleurs et autres contrôles
        document.querySelectorAll('input').forEach(input => {
          input.addEventListener('input', updatePreview);
        });
        
        // Gestion du fond de prévisualisation
        document.querySelectorAll('#background-selector div').forEach(div => {
          div.addEventListener('click', () => {
            document.querySelectorAll('#background-selector div').forEach(d => {
              d.classList.remove('active');
            });
            div.classList.add('active');
            previewerEl.style.backgroundColor = div.dataset.color;
          });
        });
        
        // Gestion du zoom
        document.getElementById('zoom-in').addEventListener('click', () => {
          currentZoom = Math.min(currentZoom + 25, 400);
          updateZoom();
        });
        
        document.getElementById('zoom-out').addEventListener('click', () => {
          currentZoom = Math.max(currentZoom - 25, 25);
          updateZoom();
        });
        
        // Gestion des options d'affichage
        document.getElementById('showBorders').addEventListener('change', updatePreviewStyles);
        document.getElementById('showTransparent').addEventListener('change', updatePreviewStyles);
        
        function updateZoom() {
          document.getElementById('zoom-value').value = `${currentZoom}%`;
          updatePreviewStyles();
        }
        
        function updatePreviewStyles() {
          const showBorders = document.getElementById('showBorders').checked;
          const showTransparent = document.getElementById('showTransparent').checked;
          
          document.querySelectorAll('.preview-image-container').forEach(container => {
            // Appliquer le zoom
            container.style.transform = `scale(${currentZoom / 100})`;
            container.style.transformOrigin = 'top left';
            container.style.margin = currentZoom > 100 ? '20px' : '0'; // Ajouter de l'espace pour les grandes images
            
            // Appliquer les bordures
            container.style.border = showBorders ? '1px dashed #aaa' : 'none';
            
            // Appliquer le fond transparent
            container.style.backgroundImage = showTransparent ? 
              'url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAABnSURBVHja7M6xDQAgDAPA0vef3BmcA0RpKMwQSHT5Jvh9Mvb9JqSqGnvODO0b2vrGelRrDbd3/MiAGaeBBdMxYjL0dGYyWkx3HhtugXYL2DA7WNppMMIUQlsvs2Caf6QZE1nQPwAAAP//AwAYhgckvOAFCQAAAABJRU5ErkJggg==\')' : 
              'none';
          });
        }
        
        function updatePreview() {
          const previewText = "12,345.67€";
          previewerEl.textContent = `Aperçu: ${previewText}`;
        }

        // Fonction pour mesurer les caractères et déterminer les dimensions maximales
        function measureCharacters(chars) {
          const fontSize = parseInt(document.getElementById('fontSize').value);
          ctx.font = `${fontSize}px Bangers`;
          
          let maxWidth = 0;
          let maxHeight = fontSize * 1.4; // Hauteur approximative
          
          chars.split('').forEach(char => {
            const metrics = ctx.measureText(char);
            maxWidth = Math.max(maxWidth, metrics.width);
          });
          
          return { width: maxWidth, height: maxHeight };
        }
        
        function createNumberImage(char, uniformDimensions = null) {
          const fontSize = parseInt(document.getElementById('fontSize').value);
          const strokeWidth = parseInt(document.getElementById('strokeWidth').value);
          const strokeColor = document.getElementById('strokeColor').value;
          
          // Récupération des valeurs du gradient
          const gradientDirectionX = parseInt(document.getElementById('gradientDirectionX').value);
          const colors = [
            { color: document.getElementById('gradientColor1').value, position: parseInt(document.getElementById('gradientPos1').value) / 100 },
            { color: document.getElementById('gradientColor2').value, position: parseInt(document.getElementById('gradientPos2').value) / 100 },
            { color: document.getElementById('gradientColor3').value, position: parseInt(document.getElementById('gradientPos3').value) / 100 },
            { color: document.getElementById('gradientColor4').value, position: parseInt(document.getElementById('gradientPos4').value) / 100 }
          ];
          
          // Tri des couleurs par position
          colors.sort((a, b) => a.position - b.position);
          
          const shadowColor = document.getElementById('shadowColor').value;
          const shadowBlur = parseInt(document.getElementById('shadowBlur').value);
          const shadowOffsetX = parseInt(document.getElementById('shadowOffsetX').value);
          const shadowOffsetY = parseInt(document.getElementById('shadowOffsetY').value);
          
          // Utiliser les paddings individuels
          const paddingTop = parseInt(document.getElementById('paddingTop').value);
          const paddingRight = parseInt(document.getElementById('paddingRight').value);
          const paddingBottom = parseInt(document.getElementById('paddingBottom').value);
          const paddingLeft = parseInt(document.getElementById('paddingLeft').value);
          
          // Déterminer les dimensions
          ctx.font = `${fontSize}px Bangers`;
          ctx.textBaseline = 'middle';
          const metrics = ctx.measureText(char);
          
          // Calculer la hauteur approximative
          const height = fontSize * 1.4;
          
          // Définir la taille avec padding
          let width, canvasHeight;
          
          if (uniformDimensions) {
            // Utiliser les dimensions uniformes si spécifiées
            width = uniformDimensions.width + paddingLeft + paddingRight;
            canvasHeight = uniformDimensions.height + paddingTop + paddingBottom;
          } else {
            // Utiliser les dimensions basées sur le caractère
            width = metrics.width + paddingLeft + paddingRight;
            canvasHeight = height + paddingTop + paddingBottom;
          }
          
          canvas.width = width;
          canvas.height = canvasHeight;
          
          // Effacer le canvas
          ctx.clearRect(0, 0, width, canvasHeight);
          
          // Configuration du contexte
          ctx.font = `${fontSize}px Bangers`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Position du texte (centre horizontal, avec décalage si padding asymétrique)
          const textX = width / 2 + (paddingLeft - paddingRight) / 2;
          const textY = canvasHeight / 2 + (paddingTop - paddingBottom) / 2;
          
          // Ajouter l'ombre
          ctx.shadowColor = shadowColor;
          ctx.shadowBlur = shadowBlur;
          ctx.shadowOffsetX = shadowOffsetX;
          ctx.shadowOffsetY = shadowOffsetY;
          
          // Dessiner le contour
          ctx.lineWidth = strokeWidth;
          ctx.strokeStyle = strokeColor;
          ctx.strokeText(char, textX, textY);
          
          // Réinitialiser l'ombre pour le remplissage
          ctx.shadowColor = 'transparent';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
          
          // Calculer la direction du gradient en fonction du pourcentage
          const gradientX = (canvas.width * gradientDirectionX) / 100;
          
          // Créer le dégradé avec la direction x personnalisée
          const gradient = ctx.createLinearGradient(0, 0, gradientX, canvasHeight);
          
          // Ajouter les arrêts de couleur selon les positions spécifiées
          colors.forEach(colorInfo => {
            gradient.addColorStop(colorInfo.position, colorInfo.color);
          });
          
          // Dessiner le texte avec le dégradé
          ctx.fillStyle = gradient;
          ctx.fillText(char, textX, textY);
          
          return {
            dataURL: canvas.toDataURL('image/png'),
            width: canvas.width,
            height: canvas.height
          };
        }
        
        function generateImages() {
          previewEl.innerHTML = '';
          images = {};
          
          const chars = document.getElementById('characters').value || "0123456789.,x€$£%";
          const useUniformSize = document.getElementById('useUniformSize').checked;
          const uniformSizeChars = document.getElementById('uniformSizeChars').value;
          
          // Calculer les dimensions uniformes si nécessaire
          let uniformDimensions = null;
          if (useUniformSize && uniformSizeChars) {
            uniformDimensions = measureCharacters(uniformSizeChars);
          }
          
          chars.split('').forEach(char => {
            // Déterminer si ce caractère doit avoir une taille uniforme
            const shouldBeUniform = useUniformSize && uniformSizeChars.includes(char);
            const imageData = createNumberImage(char, shouldBeUniform ? uniformDimensions : null);
            images[char] = imageData;
            
            // Ajouter à la prévisualisation
            const container = document.createElement('div');
            container.className = 'preview-item';
            
            const imageContainer = document.createElement('div');
            imageContainer.className = 'preview-image-container';
            imageContainer.style.width = `${imageData.width}px`;
            imageContainer.style.height = `${imageData.height}px`;
            
            const img = document.createElement('img');
            img.src = imageData.dataURL;
            img.alt = `Caractère ${char}`;
            img.title = `Caractère ${char}`;
            
            const dimensions = document.createElement('div');
            dimensions.className = 'image-dimensions';
            dimensions.textContent = `${imageData.width}×${imageData.height}`;
            
            imageContainer.appendChild(img);
            imageContainer.appendChild(dimensions);
            
            const label = document.createElement('div');
            label.className = 'char-label';
            label.textContent = char === ' ' ? 'espace' : char;
            
            container.appendChild(imageContainer);
            container.appendChild(label);
            previewEl.appendChild(container);
          });
          
          // Mettre à jour les styles d'affichage
          updatePreviewStyles();
        }
        
        function downloadAll() {
          const entries = Object.entries(images);
          let index = 0;
          
          // Message de téléchargement
          const downloadMsg = document.createElement('div');
          downloadMsg.style.position = 'fixed';
          downloadMsg.style.top = '20px';
          downloadMsg.style.left = '50%';
          downloadMsg.style.transform = 'translateX(-50%)';
          downloadMsg.style.backgroundColor = 'rgba(0,0,0,0.8)';
          downloadMsg.style.color = '#fff';
          downloadMsg.style.padding = '10px 20px';
          downloadMsg.style.borderRadius = '5px';
          downloadMsg.style.zIndex = '9999';
          downloadMsg.textContent = `Téléchargement en cours: 0/${entries.length}`;
          document.body.appendChild(downloadMsg);
          
          function downloadNext() {
            if (index >= entries.length) {
              // Téléchargement terminé
              downloadMsg.textContent = `Téléchargement terminé: ${entries.length}/${entries.length}`;
              setTimeout(() => {
                document.body.removeChild(downloadMsg);
              }, 3000);
              return;
            }
            
            const [char, imageData] = entries[index];
            const link = document.createElement('a');
            link.href = imageData.dataURL;
            
            // Remplacer les caractères spéciaux pour éviter les problèmes de nommage de fichier
            let safeName = char;
            switch (char) {
              case '.': safeName = 'point'; break;
              case ',': safeName = 'virgule'; break;
              case ' ': safeName = 'espace'; break;
              case '/': safeName = 'slash'; break;
              case '\\': safeName = 'backslash'; break;
              case ':': safeName = 'deuxpoints'; break;
              case '*': safeName = 'asterisque'; break;
              case '?': safeName = 'question'; break;
              case '"': safeName = 'guillemet'; break;
              case '<': safeName = 'inferieur'; break;
              case '>': safeName = 'superieur'; break;
              case '|': safeName = 'pipe'; break;
              case '$': safeName = 'dollar'; break;
              case '€': safeName = 'euro'; break;
              case '£': safeName = 'livre'; break;
              case '%': safeName = 'pourcent'; break;
              case 'x': safeName = 'x'; break;
              default: safeName = char;
            }
            
            link.download = `number_${safeName}.png`;
            link.click();
            
            index++;
            // Mettre à jour l'indicateur de progression
            downloadMsg.textContent = `Téléchargement en cours: ${index}/${entries.length}`;
            
            // Ajouter un délai entre les téléchargements pour éviter le blocage du navigateur
            setTimeout(downloadNext, 300);
          }
          
          // Démarrer le processus de téléchargement
          downloadNext();
        }
        
        // Attacher les événements aux boutons
        document.getElementById('generate').addEventListener('click', generateImages);
        document.getElementById('downloadAll').addEventListener('click', downloadAll);
        
        // Générer les images au démarrage
        generateImages();
      }
    });
  </script>
</body>
</html>